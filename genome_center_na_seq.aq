{"config":{"title":"Genome_Center_Rna_Seq","description":"Goes through the Genome Center's standard RNA-Seq workflow","copyright":"My Organization","version":"0.0.1","authors":[{"name":"Cannon Malloyr","affiliation":"UW"}],"maintainer":{"name":"Cannon Mallory","email":"malloc3@uw.edu"},"acknowledgements":[{"name":"First Last","affiliation":"A Place"}],"github":{"user":"malloc3","repo":"genome_center_na_seq"},"keywords":null,"aquadoc_version":"1.0.2","aquarium_version":"\u003c%= Bioturk::Application.config.aquarium_version %\u003e"},"components":[{"library":{"name":"CollectionActions","category":"Collection_Management","code_source":"#Cannon Mallory\n#malloc3@uw.edu\n#\n#This module is to contain commen actions done with collections\n#This includes moving them, finding locations, putting away individual collections.\n# or putting a whole collection on a machine etc\n#These actions should involve the WHOLE plate not individual wells.  The colleciton is doing the whole action\nmodule CollectionActions\n    \n    #stores all input collections from all operations\n    #\n    # @operations OperationsList the operation list that all input collections should be stored\n    # @location Optional String, the location that the items are to be moved to\n    def store_input_collections(operations, location = nil)\n        show do \n           title \"Put Away the Following Items\"\n           operations.each do |op|\n              array_of_input_fv = op.inputs.reject{|fv| fv.collection == nil}\n              table table_of_object_locations(array_of_input_fv, location)\n          end\n        end\n    end\n    \n    #stores all output collections from all operations\n    #\n    # @operations OperationsList the operation list that all output collections should be stored\n    def store_output_collections(operations, location = nil)\n        show do \n           title \"Put Away the Following Items\"\n           array_of_input_fv = []\n           operations.each do |op|\n            array_of_input_fv = array_of_input_fv + op.outputs.reject{|fv| fv.collection == nil}\n           end\n           table table_of_object_locations(array_of_input_fv, location)\n        end\n    end\n    \n    #Shows the locations of all the collections in the array of FV.\n    #Can move the location to optional \"location\"\n    #\n    # array_of_fv Array[FieldValues] an array of FieldValues\n    # @location string Optional moves all collections to that location\n    # Returns\n    # @Table    Table   Returns a Table\n    def table_of_object_locations(array_of_fv, location = nil)\n        obj_array = []\n        array_of_fv.each do |fv|\n            if fv.collection != nil\n                obj_array.push fv.collection\n            elsif fv.item != nil\n                obj_array.push fv.item\n            else\n                raise \"Invalid class.  Neither collection nor item.\"\n            end\n        end\n        obj_array = obj_array.uniq\n        set_locations(obj_array, location) if location != nil\n        return get_item_locations(obj_array)\n    end\n\n\n    #Sets the location of all objects in array to some given locations\n    #\n    # @obj_array  Array[Collection] or Array[Items] an array of any objects that extend class item\n    # @location     String the location to be moved to (just string or Wizard if Wizard Exist)\n    def set_locations(obj_array, location)\n        obj_array.each do |obj|\n            obj.move(location)\n        end\n    end\n    \n    #instructions to store a specific collection\n    #\n    # @collection Collection the collection that is to be put away\n    # Returns:\n    # @ Table of collections and their locations\n    def get_item_locations(obj_array)\n        tab = [['ID', 'Collection Type', 'Location']]\n        obj_array.each do |obj|\n            tab.push([obj.id, obj.object_type.name, obj.location])\n        end\n        return tab\n    end\n    \n    #Instructions to store a specific item\n    #\n    # @obj_item Item/Object that extends class item or Array[Item/item that \n    #       extends class item]         all items that need to be stored\n    # @location Optional String Sets the location of the items if included\n    def store_items(obj_item, location = nil)\n        show do\n            title \"Put Away the Following Items\"\n            if obj_item.class != Array\n                set_locations([obj_item], location) if location != nil\n                table get_item_locations([obj_item])\n            else\n                set_locations(obj_item, location) if location != nil\n                table get_item_location(obj_item)\n            end\n        end\n    end\n\n    #Gives directions to throwaway an object (collection or item)\n    #\n    # @obj or array of Item or Object that extends class Item  eg collection\n    # @hazardous boolean if hazardous then true\n    def trash_object(obj_array, hazardous = true)\n        #toss QC plate\n        if obj_array.class != Array\n            obj_array = [obj_array]\n        end\n        \n        show do\n            title \"Trash the following items\"\n            tab = [['Item', 'Waste Container']]\n            obj_array.each do |obj|\n                obj.mark_as_deleted\n                if hazardous\n                    waste_container = \"Biohazard Waste\"\n                else\n                    waste_container = \"Trash Can\"\n                end\n                tab.push([obj.id, waste_container])\n            end\n            table tab\n        end\n    end\n\n    #makes a new plate and provides instructions to label said plate\n    #\n    # @ c_type string the collection type\n    # @ label_plate boolean weather to get and label plate or no default true\n    # Returns\n    # @collection collection the collection it makes\n    def make_new_plate(c_type, label_plate = true)\n        working_plate = Collection.new_collection(c_type)\n        get_and_label_new_plate(working_plate) if label_plate\n        return working_plate\n    end\n\n\n\n    #Instructions on getting and labeling new plate\n    #\n    #@plate Collection plate to be gotten and labeled\n    def get_and_label_new_plate(plate)\n        show do\n        title \"Get and Label Working Plate\"\n        note \"Get a \u003cb\u003e#{plate.object_type.name}\u003c/b\u003e and lable ID: \u003cb\u003e#{plate.id}\u003c/b\u003e\"\n        end\n    end\n    \n    \nend"}},{"library":{"name":"CollectionDisplay","category":"Collection_Management","code_source":"#Justin Vrana\n#\n#modified by:\n#Cannon Mallory\n#malloc3@uw.edu\n#\n#Modifications include:\n# Documentation (yet to happen)\n#\n# This module is for displaying information about collections in effecient easy to use ways\n#\n# TODO Make the collection displays so that they wont always be checkable cause that gets annoying\nmodule CollectionDisplay\n  def create_collection_table(collection)\n    size = collection.object_type.rows * collection.object_type.columns\n    slots = (1..size).to_a\n    slots.each_slice(collection.object_type.columns).map do |row|\n      row.map do |col|\n        {content: col, class: 'td-empty-slot'}\n      end\n    end\n  end\n\n  def highlight tbl, row, col, id\n    tbl[row][col] = {content: id, class: 'td-filled-slot', check: true}\n  end\n\n  # [r,c,x] list\n  def highlight_rcx(collection, rcx_list)\n    tbl = create_collection_table collection\n    rcx_list.each do |r, c, x|\n      highlight tbl, r, c, x\n    end\n    tbl\n  end\n\n  def highlight_rc collection, rc_list, \u0026rc_block\n    rcx_list = rc_list.map { |r, c|\n      block_given? ? [r, c, yield(r, c)] : [r, c, \"\"]\n    }\n    highlight_rcx collection, rcx_list\n  end\n\n  def highlight_non_empty(collection, \u0026rc_block)\n    highlight_rc collection, collection.get_non_empty, \u0026rc_block\n  end\n\n  def highlight_collection ops, id_block=nil, \u0026fv_block\n    g = ops.group_by { |op| fv_block.call(op).collection }\n    tables = g.map do |collection, grouped_ops|\n      rcx_list = grouped_ops.map do |op|\n        fv = fv_block.call(op)\n        id = id_block.call(op) if id_block\n        id ||= fv.sample.id\n        [fv.row, fv.column, id]\n      end\n      tbl = highlight_rcx collection, rcx_list\n      [collection, tbl]\n    end\n    tables\n  end\n\n  def r_c_to_slot collection, r, c\n    rows, cols = collection.dimensions = collection.object_type.rows\n    r*cols + c+1\n  end\n  \n  \n  \n  \n  def create_alpha_numeric_table(collection)\n    size = collection.object_type.rows * collection.object_type.columns\n    slots = (1..size).to_a\n    alpha_r = ('A'..'H').to_a\n    slots.each_slice(collection.object_type.columns).each_with_index.map do |row, r_idx|\n      row.each_with_index.map do |col, c_idx|\n        {content: \"#{alpha_r[r_idx]}#{c_idx + 1}\", class: 'td-empty-slot'}\n      end\n    end\n  end\n  \n  def highlight_alpha_rc collection, rc_list, \u0026rc_block\n    rcx_list = rc_list.map { |r, c|\n      block_given? ? [r, c, yield(r, c)] : [r, c, \"\"]\n    }\n    highlight_alpha_rcx(collection, rcx_list)\n  end\n  \n  def highlight_alpha_rcx(collection, rcx_list)\n     tbl = create_alpha_numeric_table(collection)\n     rcx_list.each do |r, c, x|\n         highlight tbl, r, c, x\n     end\n     return tbl\n  end\n\n  def highlight_alpha_non_empty collection, \u0026rc_block\n    highlight_alpha_rc collection, collection.get_non_empty, \u0026rc_block\n  end\n      \nend"}},{"library":{"name":"CollectionTransfer","category":"Collection_Management","code_source":"#Cannon Mallory\n#malloc3@uw.edu\n#\n# This module includes helfpul methods for transferring items into and out of collections\n# Currently it only has collection --\u003e collection transfers \n#TODO Item --\u003e collection and collection --\u003e item transfers. (not applicable for current project so not added)\nneeds \"Standard Libs/Units\"\n\nmodule CollectionTransfer\n  \n  include Units\n\n\n  #Provides instructions to transfer sample from an input_collection to a working_working collection\n  #The array of samples must exist in both collections.  Both collections must already have the samples\n  #associated with it else an error will be thrown.\n  #\n  # @input_collection Collection  the collection that samples will be transfered from\n  # @working_collection Collection the collection that samples will be transfered to\n  # @transfer_vol Int volume in ul of sample to transfer\n  #\n  # @arry_samples  Array[Sample] Optional an array of all the samples that are to be transfered\n        #if black then all samples will be transfered\n  def transfer_to_working_plate(input_collection, working_collection, arry_sample = nil, transfer_vol)\n    if arry_sample == nil\n      arry_sample = input_collection.parts.map{|part| part.sample if part.class != \"Sample\"}\n    end\n    input_rcx = []\n    output_rcx = []\n    arry_sample.each do |sample|\n      input_location_array = get_item_sample_location(input_collection, sample)\n      input_sample_location = get_alpha_num_location(input_collection, sample)\n\n      output_location_array = get_item_sample_location(working_collection, sample)\n      output_sample_location = get_alpha_num_location(input_collection, sample)\n\n      input_location_array.each do |sub_array|\n        sub_array.push(input_sample_location)\n        input_rcx.push(sub_array)\n      end\n\n      output_location_array.each do |sub_array|\n          sub_array.push(output_sample_location)\n          output_rcx.push(sub_array)\n      end\n    end\n\n    associate_plate_to_plate(working_collection, input_collection, \"Input Plate\", \"Input Item\")\n\n    show do \n      title \"Transfer from Stock Plate to Working Plate\"\n      note \"Please transfer #{transfer_vol} #{MICROLITERS} from stock plate (ID:#{input_collection.id}) to working \n                                plate (ID:#{working_collection.id}) per tables below\"\n      note \"Separator\"\n      note \"Stock Plate (ID: #{input_collection.id}):\"\n      table highlight_rcx(input_collection, input_rcx)  #TODO need RCX list for transfer here!! not whole collection\n      note \"Working Plate (ID: #{working_collection}):\"\n      table highlight_rcx(working_collection, output_rcx)\n    end\n  end\n\n\n  #Instructions to transfer from input plates to working_plates when an array of samples in collections is used\n  #Will group samples in same collection together for easier transfer.  Uses transfer_to_working_plate method\n  #\n  # @working_plate Collection (Should have samples already associated to it)\n  # @input_fv_array Array[FieldValues] an array of field values of collections.  Typically from\n        # op.input_array(INPUT_ARRAY_NAME) when the individual inputs are samples in a collection\n  # @transfer_vol Int volume in ul of sample to transfer\n  def transfer_from_array_collections(input_fv_array, working_plate, transfer_vol)\n    sample_arry_by_collection = input_fv_array.group_by{|fv| fv.collection}\n    sample_arry_by_collection.each do |input_collection, fv_array|\n      sample_array = fv_array.map{|fv| fv.sample}\n      transfer_to_working_plate(input_collection, working_plate, sample_array, transfer_vol)\n    end\n  end\n\n\n  #Instructions on relabeling plates to new plate ID\n  #\n  #@plate1 Collection plate to be relabel\n  #@plate2 Collection new plate label\n  def relabel_plate(plate1, plate2)\n    show do\n      title \"Rename Plate\"\n      note \"Relabel plate #{plate1.id} with #{plate2.id}\"\n    end\n  end\n\n\n  #determins if there are multiple output plate\n  #\n  #@operations OperationList list of operations in job\n  #returns boolean true if multiple plates \n  def multi_input_plates?(operations)\n    if get_num_plates(operations, 'input') \u003e 1\n      return true\n    else\n      return false \n    end\n  end\n\n  #determins if there are multiple output plate\n  #\n  #@operations OperationList list of operations in job\n  #returns boolean true if multiple plates \n  def multi_output_plates?(operations)\n    if get_num_plates(operations, 'output') \u003e 1\n      return true\n    else\n      return false \n    end\n  end\n\n  #gets the number of plate\n  #\n  #@operations OperationList list of operations in job\n  #@in_out String input or output determines if its input or output collections\n  #returns Int the number of plates \n  def get_num_plates(operations, in_out)\n    return get_array_of_collections(operations, in_out).length\n  end\n\n  #gets the number of plate\n  #\n  #@operations OperationList list of operations in job\n  #@in_out String input or output determines if its input or output collections\n  #returns Array[collection] the number of plates \n  def get_array_of_collections(operations, in_out)\n    collection_array = []\n    operations.each do |op|\n      obj_array = op.inputs if in_out = \"input\"\n      obj_array = op.outputs if in_out = \"output\"\n      obj_array.each do |fv|\n        if fv.collection != nil\n          collection_array.push(fv.collection)\n        end\n      end\n    end\n    return collection_array.uniq\n  end\n\n\n  #associates all items in the added_plate to the items in the base plate\n  # Associates corrosponding well locations.  Assocaites plate to plate and well to well\n  # Only associates to wells that have a part in them\n  #\n  #@base_plate collcetion the plate that is getting the association\n  #@added_plate collection the plate that is transfering the association\n  def associate_plate_to_plate(base_plate, added_plate, plate_key, item_key)\n    base_plate.associate(plate_key, added_plate)\n    added_parts = added_plate.parts\n    base_parts = base_plate.parts\n    base_parts.each_with_index do |part, idx|\n      part.associate(item_key, added_parts[idx])\n    end\n  end\nend"}},{"library":{"name":"SampleManagement","category":"Collection_Management","code_source":"#Cannon Mallory\n#malloc3@uw.edu\n#\n#This is to facilitate sample management within collection\nmodule SampleManagement\n\n  ALPHA26 = (\"A\"...\"Z\").to_a\n\n  #Gets the location string of a sample in a collection \n  #Returns Alpha numerical string eg A1 or if the sample is\n  #in multiple locations will return A1, A2, A3\n  #\n  #@collection Collection the collection that the sample is in\n  #@sample Sample the Sample that you want the Alpha Numerical location for\n  def get_alpha_num_location(collection, sample)\n    loc_array = get_item_sample_location(collection, sample)\n    string = \"\"\n    loc_array.each_with_index do |loc, idx|\n      string = string + \", \" if idx \u003e 0\n      loc.each_with_index do |rc, idx|\n        if idx.even?\n          string = string + ALPHA26[rc]\n        else\n          string = string + \"#{rc+1}\"\n        end\n      end\n    end\n    return string\n  end\n\n\n  #Finds the location of what ever is give either item or sample\n  #\n  # @collection collection the collection containing the thing\n  # @part item,part, or sample that is to be found\n  # returns\n  # @Array[array[r,c]] sometimes samples are in multiple places so array of array\n  def get_item_sample_location(collection, part)\n    location_array = collection.find(part)\n    return location_array\n  end\n\n\n  #Assigns samples to specific well locations\n  #\n  #input:  working_plate   Collection\n  def add_fv_array_samples_to_collection(input_array, working_plate)\n      sample_array = []\n      input_array = input_array.sort_by{|fv| [fv.collection.find(fv.sample).first[1],fv.collection.find(fv.sample).first[0]]}\n      input_array.each_with_index do |fv, idx|\n        sample = fv.sample\n        sample_array \u003c\u003c sample\n      end\n      slots_left = working_plate.get_empty.length\n      raise \"There are too many samples in this batch.\" if sample_array.length \u003e slots_left\n      working_plate.add_samples(sample_array) #TODO add error checking for if the working_plate is full\n  end\n\n\n  #This replaces the operations.make command.  It ensures that all items in output_fv_array\n  #Remain in the same collection (instead of being put into different collections)\n  #\n  # @output_fv_array array[fv] array of field values\n  # @working_plate collection the destination collection.\n  def make_output_plate(output_fv_array, working_plate)\n    output_fv_array.each do |fv|\n        r_c = working_plate.find(fv.sample).first\n        fv.set(collection: working_plate, row: r_c[0], column: r_c[1])\n      end\n  end\n\n  #This finds a sample from an alpha numberical string location(e.g. A1, B1)\n  #\n  # @collection collection a collection that the part is located in\n  # @loc string  the location in the collection for part (A1, B3, C7)\n  # Returns:\n  # @part item the item at that location\n  def part_alpha_num(collection, loc)\n    row = ALPHA26.find_index(loc[0,1])\n    col = loc[1...].to_i - 1\n\n    dem = collection.dimensions \n    raise \"Location outside collection dimensions\" if row \u003e dem[0] || col \u003e dem[1]\n    part = collection.part(row,col)\n    return part\n  end\n\nend"}},{"sample_types":[{"id":1,"name":"RNA Sample","description":"An individual unique sample of RNA","created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","field_types":[{"id":1,"parent_id":1,"name":"Customer","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":2,"parent_id":1,"name":"Code","ftype":"string","choices":null,"array":false,"required":true,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":3,"parent_id":1,"name":"Version","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":4,"parent_id":1,"name":"Type","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":5,"parent_id":1,"name":"Label","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":6,"parent_id":1,"name":"Organism","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":7,"parent_id":1,"name":"Conc","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":8,"parent_id":1,"name":"Volume","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":9,"parent_id":1,"name":"Pool","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]}],"object_types":[{"id":3,"name":"96 Well Sample Plate","description":"96 well sample plate","min":0,"max":1000,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:32:04.000-07:00","unit":"plate","cost":0.01,"release_method":"return","release_description":"","sample_type_id":null,"image":"","prefix":"","rows":8,"columns":12,"sample_type_name":null}],"operation_type":{"name":"C_DNA_QC","category":"RNA_Seq","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Input Array","sample_types":["RNA Sample"],"object_types":["96 Well Sample Plate"],"part":false,"array":true,"routing":"IA","preferred_operation_type_id":3,"preferred_field_type_id":12,"choices":null}],"protocol":"#Cannon Mallory\n#UW-BIOFAB\n#03/04/2019\n#malloc3@uw.edu\n#\n#\n#This Protocol is to Quality check the C-DNA created.\n\nneeds \"Standard Libs/Debug\"\nneeds \"Standard Libs/CommonInputOutputNames\"\nneeds \"Standard Libs/Units\"\n\nneeds \"Collection_Management/CollectionDisplay\"\nneeds \"Collection_Management/CollectionTransfer\"\nneeds \"Collection_Management/CollectionActions\"\nneeds \"Collection_Management/SampleManagement\"\nneeds \"RNA_Seq/WorkflowValidation\"\nneeds \"RNA_Seq/KeywordLib\"\n\n\nclass Protocol\n  include Debug, CollectionDisplay, CollectionTransfer, SampleManagement\n  include CollectionActions, WorkflowValidation, CommonInputOutputNames, KeywordLib\n\n  TRANSFER_VOL = 20   #volume of sample to be transfered in ul\n\n\n  def main\n    validate_inputs(operations)\n    \n    working_plate = make_new_plate(C_TYPE)\n    \n    operations.retrieve\n\n    operations.each do |op|\n      input_fv_array = op.input_array(INPUT_ARRAY)\n      add_fv_array_samples_to_collection(input_fv_array, working_plate)\n      transfer_from_array_collections(input_fv_array, working_plate, TRANSFER_VOL)\n    end\n    \n    store_input_collections(operations)\n    take_qc_measurments(working_plate)\n    trash_object(working_plate)\n\n  end\n\n\n  # Instruction on taking the QC measurements themselves.\n  # Currently not operational but associates random concentrations for testing\n  #\n  #TODO complete this and make it actually look at CSV Files\n  def take_qc_measurments(working_plate)\n    input_rcx = []\n    operations.each do |op|\n      input_array = op.input_array(INPUT_ARRAY)\n      input_items = input_array.map{|fv| fv.item}\n      arry_sample = input_array.map{|fv| fv.sample}\n      input_items.each_with_index do |item, idx|\n        item.associate(QC2_KEY, \"Pass\")\n        sample = arry_sample[idx]\n        working_plate_loc_array = working_plate.find(sample)\n        working_plate_loc_array.each do |sub_array|\n          sub_array.push(\"#{item.get(QC2_KEY)}\")\n          input_rcx.push(sub_array)\n        end\n      end\n    end\n\n    show do\n      title \"Perform QC Measurements\"\n      note \"Please Attach excel files\"\n      note \"For testing purposes each sample will assume to pass\"\n      note \"This will eventually come from a CSV file\"\n      table highlight_rcx(working_plate, input_rcx)\n    end\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"","timing":null}},{"sample_types":[{"id":1,"name":"RNA Sample","description":"An individual unique sample of RNA","created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","field_types":[{"id":1,"parent_id":1,"name":"Customer","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":2,"parent_id":1,"name":"Code","ftype":"string","choices":null,"array":false,"required":true,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":3,"parent_id":1,"name":"Version","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":4,"parent_id":1,"name":"Type","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":5,"parent_id":1,"name":"Label","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":6,"parent_id":1,"name":"Organism","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":7,"parent_id":1,"name":"Conc","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":8,"parent_id":1,"name":"Volume","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":9,"parent_id":1,"name":"Pool","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]}],"object_types":[{"id":3,"name":"96 Well Sample Plate","description":"96 well sample plate","min":0,"max":1000,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:32:04.000-07:00","unit":"plate","cost":0.01,"release_method":"return","release_description":"","sample_type_id":null,"image":"","prefix":"","rows":8,"columns":12,"sample_type_name":null}],"operation_type":{"name":"Normalization Pooling","category":"RNA_Seq","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Input Array","sample_types":["RNA Sample"],"object_types":["96 Well Sample Plate"],"part":false,"array":true,"routing":"IA","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Output Array","sample_types":["RNA Sample"],"object_types":["96 Well Sample Plate"],"part":false,"array":true,"routing":"IA","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"#Cannon Mallory\n#UW-BIOFAB\n#03/04/2019\n#malloc3@uw.edu\n#\n#\n#This protocol is for total RNA QC.  It Will take in a batch of samples, replate these\n#samples together onto a 96 well plate that will then go through a QC protocols including\n#getting the concentrations of the original sampole.  These concentrations will then be associated\n#with the original sample for use later.\n\n\n#Currently build plate needs a bit of work.  It works by order of input array and not by order of sample location on plate\n\n\nneeds \"Standard Libs/Debug\"\nneeds \"Standard Libs/CommonInputOutputNames\"\nneeds \"Standard Libs/Units\"\n\nneeds \"Collection_Management/CollectionDisplay\"\nneeds \"Collection_Management/CollectionTransfer\"\nneeds \"Collection_Management/CollectionActions\"\nneeds \"Collection_Management/SampleManagement\"\nneeds \"RNA_Seq/WorkflowValidation\"\nneeds \"RNA_Seq/KeywordLib\"\n\nclass Protocol\n  include Debug, CollectionDisplay, CollectionTransfer, SampleManagement, CollectionActions\n  include WorkflowValidation, CommonInputOutputNames, KeywordLib\n  C_TYPE = \"96 Well Sample Plate\"\n\n  TRANSFER_VOL = 20   #volume of sample to be transfered in ul\n\n\n  def main\n\n    validate_inputs(operations, inputs_match_outputs = true)\n\n    validate_cdna_qc(operations)\n\n    multi_plate = multi_input_plates?(operations)\n\n    working_plate = make_new_plate(C_TYPE, multi_plate)\n  \n    operations.retrieve\n\n    operations.each do |op|\n      input_fv_array = op.input_array(INPUT_ARRAY)\n      output_fv_array = op.output_array(OUTPUT_ARRAY)\n      add_fv_array_samples_to_collection(input_fv_array, working_plate)\n      make_output_plate(output_fv_array, working_plate)\n      transfer_from_array_collections(input_fv_array, working_plate, TRANSFER_VOL) if multi_plate\n    end\n\n    if !multi_plate\n      input_plate = operations.first.input_array(INPUT_ARRAY).first.collection\n      relabel_plate(input_plate,working_plate) if !multi_plate\n      input_plate.mark_as_deleted\n    else\n      trash_object(get_array_of_collections(operations, 'input')) if multi_plate\n    end\n\n    normalization_pooling(working_plate)\n\n    store_output_collections(operations, 'Freezer')\n  end\n\n  #Instructions for performing RNA_PREP\n  #\n  # @working_plate collection the plate that has all samples in it\n  def normalization_pooling(working_plate)\n    show do\n      title \"Do the Normalization Pooling Steps\"\n      note \"Run typical Normalization Pooling protocol with plate #{working_plate.id}\"\n      table highlight_non_empty(working_plate)\n    end\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"","timing":null}},{"sample_types":[{"id":1,"name":"RNA Sample","description":"An individual unique sample of RNA","created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","field_types":[{"id":1,"parent_id":1,"name":"Customer","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":2,"parent_id":1,"name":"Code","ftype":"string","choices":null,"array":false,"required":true,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":3,"parent_id":1,"name":"Version","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":4,"parent_id":1,"name":"Type","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":5,"parent_id":1,"name":"Label","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":6,"parent_id":1,"name":"Organism","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":7,"parent_id":1,"name":"Conc","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":8,"parent_id":1,"name":"Volume","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":9,"parent_id":1,"name":"Pool","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]},{"id":4,"name":"Plasmid","description":"A circular piece of double stranded DNA","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","field_types":[{"id":30,"parent_id":4,"name":"Sequence","ftype":"url","choices":null,"array":false,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":31,"parent_id":4,"name":"Sequence Verification","ftype":"url","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":32,"parent_id":4,"name":"Bacterial Marker","ftype":"string","choices":"Amp,Kan,Amp + Kan,Spec,Kan + Spec,Chlor,Tet,NA,Other","array":false,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":33,"parent_id":4,"name":"Yeast Marker","ftype":"string","choices":"HIS,TRP,URA,LEU,NatMX,KanMX,HygMX,BleoMX,5FOA,NA,Other","array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":21,"field_type_id":33,"sample_type_id":5,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":5,"name":"Primer","description":"A short double stranded piece of DNA for PCR and sequencing","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["Primer"],"object_types":[null]},{"id":34,"parent_id":4,"name":"Length","ftype":"number","choices":null,"array":false,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":35,"parent_id":4,"name":"Sequencing Primers","ftype":"sample","choices":null,"array":true,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":22,"field_type_id":35,"sample_type_id":5,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":5,"name":"Primer","description":"A short double stranded piece of DNA for PCR and sequencing","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["Primer"],"object_types":[null]},{"id":36,"parent_id":4,"name":"QC Primer1","ftype":"sample","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":23,"field_type_id":36,"sample_type_id":5,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":5,"name":"Primer","description":"A short double stranded piece of DNA for PCR and sequencing","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["Primer"],"object_types":[null]},{"id":37,"parent_id":4,"name":"QC Primer2","ftype":"sample","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":24,"field_type_id":37,"sample_type_id":5,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":5,"name":"Primer","description":"A short double stranded piece of DNA for PCR and sequencing","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["Primer"],"object_types":[null]},{"id":38,"parent_id":4,"name":"QC_length","ftype":"number","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":39,"parent_id":4,"name":"Transformation Temperature","ftype":"number","choices":"37,30","array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":40,"parent_id":4,"name":"Comp Cells","ftype":"sample","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":25,"field_type_id":40,"sample_type_id":6,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":6,"name":"E coli strain","description":"A strain of E coli distinguished from others by genomic (not plasmid) modifications.","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["E coli strain"],"object_types":[null]}]},{"id":5,"name":"Primer","description":"A short double stranded piece of DNA for PCR and sequencing","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","field_types":[{"id":41,"parent_id":5,"name":"Overhang Sequence","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":42,"parent_id":5,"name":"Anneal Sequence","ftype":"string","choices":null,"array":false,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":43,"parent_id":5,"name":"T Anneal","ftype":"number","choices":null,"array":false,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]},{"id":6,"name":"E coli strain","description":"A strain of E coli distinguished from others by genomic (not plasmid) modifications.","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","field_types":[{"id":44,"parent_id":6,"name":"Parent","ftype":"sample","choices":null,"array":null,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":26,"field_type_id":44,"sample_type_id":6,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":6,"name":"E coli strain","description":"A strain of E coli distinguished from others by genomic (not plasmid) modifications.","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["E coli strain"],"object_types":[null]}]}],"object_types":[{"id":4,"name":"Total RNA 96 Well Plate","description":"96 Well plate of total RNA from customer","min":0,"max":1000000,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:32:08.000-07:00","unit":"plate","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":"","prefix":"M80C","rows":8,"columns":12,"sample_type_name":"RNA Sample"},{"id":3,"name":"96 Well Sample Plate","description":"96 well sample plate","min":0,"max":1000,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:32:04.000-07:00","unit":"plate","cost":0.01,"release_method":"return","release_description":"","sample_type_id":null,"image":"","prefix":"","rows":8,"columns":12,"sample_type_name":null},{"id":6,"name":"Fragment Stock","description":"Fragment stock in 1.5 mL tube, usually stored in M20 fridge.","min":0,"max":1000,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-03-24T08:41:54.000-07:00","updated_at":"2020-03-24T08:41:54.000-07:00","unit":"Fragment","cost":50.0,"release_method":"return","release_description":"","sample_type_id":3,"image":null,"prefix":"M20","rows":null,"columns":null,"sample_type_name":"Fragment"}],"operation_type":{"name":"RNA_Prep","category":"RNA_Seq","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Input Array","sample_types":["RNA Sample"],"object_types":["Total RNA 96 Well Plate"],"part":false,"array":true,"routing":"R","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Output Array","sample_types":["RNA Sample"],"object_types":["96 Well Sample Plate"],"part":false,"array":true,"routing":"R","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"input","name":"Frag_Example","sample_types":["Plasmid"],"object_types":["Fragment Stock"],"part":false,"array":false,"routing":"F","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"#Cannon Mallory\n#UW-BIOFAB\n#03/04/2019\n#malloc3@uw.edu\n#\n#\n#This protocol is for total RNA QC.  It Will take in a batch of samples, replate these\n#samples together onto a 96 well plate that will then go through a QC protocols including\n#getting the concentrations of the original sampole.  These concentrations will then be associated\n#with the original sample for use later.\n\n\n#Currently build plate needs a bit of work.  It works by order of input array and not by order of sample location on plate\n\n\nneeds \"Standard Libs/Debug\"\nneeds \"Standard Libs/CommonInputOutputNames\"\nneeds \"Standard Libs/Units\"\n\nneeds \"Collection_Management/CollectionDisplay\"\nneeds \"Collection_Management/CollectionTransfer\"\nneeds \"Collection_Management/CollectionActions\"\nneeds \"Collection_Management/SampleManagement\"\nneeds \"RNA_Seq/WorkflowValidation\"\nneeds \"RNA_Seq/KeywordLib\"\nneeds \"RNA_Seq/CsvDebugLib\"\n\nrequire 'csv'\n\nclass Protocol\n  include Debug, CollectionDisplay, CollectionTransfer, SampleManagement, CollectionActions\n  include WorkflowValidation, CommonInputOutputNames, KeywordLib, CsvDebugLib\n  C_TYPE = \"96 Well Sample Plate\"\n  CON_KEY = \"Stock Conc (ng/ul)\"\n\n  PLATE_ID = \"Plate ID\"\n  WELL_LOCATION = \"Well Location\"\n  ADAPTER_TRANSFER_VOL = 12 #volume of adapter to transfer\n  TRANSFER_VOL = 20   #volume of sample to be transfered in ul\n  CONC_RANGE = (50...100)\n\n\n  def main\n\n    validate_inputs(operations, inputs_match_outputs = true)\n\n    validate_concentrations(operations, CONC_RANGE)\n\n    working_plate = make_new_plate(C_TYPE)\n\n    adapter_plate = make_adapter_plate\n\n    operations.retrieve\n\n    operations.each do |op|\n      input_fv_array = op.input_array(INPUT_ARRAY)\n      output_fv_array = op.output_array(OUTPUT_ARRAY)\n      add_fv_array_samples_to_collection(input_fv_array, working_plate)\n      make_output_plate(output_fv_array, working_plate)\n      transfer_from_array_collections(input_fv_array, working_plate, TRANSFER_VOL)\n    end\n\n    associate_plate_to_plate(working_plate, adapter_plate, ADAPTER_PLATE, ADAPTER)\n\n    store_input_collections(operations)\n    rna_prep_steps(working_plate)\n    store_output_collections(operations, 'Freezer')\n  end\n\n  #Instructions for performing RNA_PREP\n  #\n  # @working_plate collection the plate that has all samples in it\n  def rna_prep_steps(working_plate)\n    show do\n      title \"Run RNA-Prep\"\n      note \"Run typical RNA-Prep Protocol with plate #{working_plate.id}\"\n      table highlight_non_empty(working_plate)\n    end\n  end\n\n\n  #Instructions for making an adapter plate\n  #\n  #returns:\n  # @adapter_plate collection the adapter plate\n  def make_adapter_plate\n    adapter_plate = make_new_plate(C_TYPE)\n    up_csv = upload_and_csv\n    col_parts_hash = sample_from_csv(up_csv)\n    validate_csv(col_parts_hash)\n    col_parts_hash.each do |collection_item, parts|\n      collection = Collection.find(collection_item.id)\n      adapter_plate.add_samples(parts)\n      transfer_to_working_plate(collection, adapter_plate, arry_sample = parts, ADAPTER_TRANSFER_VOL)\n    end\n    return adapter_plate\n  end\n\n  #Validates CSV information to make sure that it matches inputs\n  #\n  #@col_parts_hash  a hash of parts with the collection that they originate in as the key\n  def validate_csv(col_parts_hash)\n    total_samples = 0\n    total_adapters = 0\n\n    operations.each do |op|\n      total_samples = total_samples + op.input_array(INPUT_ARRAY).length\n    end\n\n    col_parts_hash.each do |col, parts|\n      total_adapters = total_adapters + parts.length\n    end\n\n    raise \"Not enough adapters for all samples in job\" if total_adapters \u003c total_samples #TODO loop back to upload\n    if total_adapters \u003e total_samples  #TODO could have it loop back to upload here too\n      show do \n        title \"More Adapters than needed\"\n        note \"The CSV uploaded adds more adapters than needed.\"\n        note \"Click OKAY to continue with this job or Cancel to Cancel\"\n      end\n    end\n  end\n\n  #Gets CSV upload and associates each CSV file with the operation in question\n  #\n  #returns\n  #@CSV CSV a csv file with the desired adapter plate wells\n  def upload_and_csv\n    up_csv = show do\n      title \"Make CSV file of Adapters\"\n      note \"Please make a \u003cb\u003eCSV\u003c/B\u003e file of all required adapters\"\n      note \"Row 1 is Reserved for headers\"\n      note \"Column 1: '#{PLATE_ID}'\"\n      note \"Column 2: '#{WELL_LOCATION}' (e.g. A1, B1)\"\n      upload var: CSV_KEY.to_sym\n    end\n    if debug\n      return CSV_DEBUG\n    else\n      return up_csv.get_response(CSV_KEY.to_sym)\n    end\n  end\n\n\n\n\n  #Parses CSV and returns an array of all the samples required\n  #@ CSV  CSV a csv file of thee adapter plate wells\n  #\n  #returns hash[key: collection, array[parts]]\n  def sample_from_csv(csv_uploads)\n    parts = []\n    csv = CSV.parse(csv_upload) if debug\n    csv_uploads.each do |upload|\n      csv = CSV.read(open(upload.url))\n      csv.each_with_index do |row, idx|\n        if idx != 0\n          collection = Collection.find(row[0])\n          part = part_alpha_num(collection, row[1])\n          parts.push(part)\n        end\n      end\n    end\n    return parts.group_by{|part| part.containing_collection}\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"","timing":null}},{"sample_types":[{"id":1,"name":"RNA Sample","description":"An individual unique sample of RNA","created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","field_types":[{"id":1,"parent_id":1,"name":"Customer","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":2,"parent_id":1,"name":"Code","ftype":"string","choices":null,"array":false,"required":true,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":3,"parent_id":1,"name":"Version","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":4,"parent_id":1,"name":"Type","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":5,"parent_id":1,"name":"Label","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":6,"parent_id":1,"name":"Organism","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":7,"parent_id":1,"name":"Conc","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":8,"parent_id":1,"name":"Volume","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":9,"parent_id":1,"name":"Pool","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:30:41.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]},{"id":4,"name":"Plasmid","description":"A circular piece of double stranded DNA","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","field_types":[{"id":30,"parent_id":4,"name":"Sequence","ftype":"url","choices":null,"array":false,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":31,"parent_id":4,"name":"Sequence Verification","ftype":"url","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":32,"parent_id":4,"name":"Bacterial Marker","ftype":"string","choices":"Amp,Kan,Amp + Kan,Spec,Kan + Spec,Chlor,Tet,NA,Other","array":false,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":33,"parent_id":4,"name":"Yeast Marker","ftype":"string","choices":"HIS,TRP,URA,LEU,NatMX,KanMX,HygMX,BleoMX,5FOA,NA,Other","array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":21,"field_type_id":33,"sample_type_id":5,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":5,"name":"Primer","description":"A short double stranded piece of DNA for PCR and sequencing","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["Primer"],"object_types":[null]},{"id":34,"parent_id":4,"name":"Length","ftype":"number","choices":null,"array":false,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":35,"parent_id":4,"name":"Sequencing Primers","ftype":"sample","choices":null,"array":true,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":22,"field_type_id":35,"sample_type_id":5,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":5,"name":"Primer","description":"A short double stranded piece of DNA for PCR and sequencing","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["Primer"],"object_types":[null]},{"id":36,"parent_id":4,"name":"QC Primer1","ftype":"sample","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":23,"field_type_id":36,"sample_type_id":5,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":5,"name":"Primer","description":"A short double stranded piece of DNA for PCR and sequencing","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["Primer"],"object_types":[null]},{"id":37,"parent_id":4,"name":"QC Primer2","ftype":"sample","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":24,"field_type_id":37,"sample_type_id":5,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":5,"name":"Primer","description":"A short double stranded piece of DNA for PCR and sequencing","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["Primer"],"object_types":[null]},{"id":38,"parent_id":4,"name":"QC_length","ftype":"number","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":39,"parent_id":4,"name":"Transformation Temperature","ftype":"number","choices":"37,30","array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":40,"parent_id":4,"name":"Comp Cells","ftype":"sample","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":25,"field_type_id":40,"sample_type_id":6,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":6,"name":"E coli strain","description":"A strain of E coli distinguished from others by genomic (not plasmid) modifications.","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["E coli strain"],"object_types":[null]}]},{"id":5,"name":"Primer","description":"A short double stranded piece of DNA for PCR and sequencing","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","field_types":[{"id":41,"parent_id":5,"name":"Overhang Sequence","ftype":"string","choices":null,"array":false,"required":false,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":42,"parent_id":5,"name":"Anneal Sequence","ftype":"string","choices":null,"array":false,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]},{"id":43,"parent_id":5,"name":"T Anneal","ftype":"number","choices":null,"array":false,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[],"sample_types":[],"object_types":[]}]},{"id":6,"name":"E coli strain","description":"A strain of E coli distinguished from others by genomic (not plasmid) modifications.","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","field_types":[{"id":44,"parent_id":6,"name":"Parent","ftype":"sample","choices":null,"array":null,"required":true,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","parent_class":"SampleType","role":null,"part":null,"routing":null,"preferred_operation_type_id":null,"preferred_field_type_id":null,"allowable_field_types":[{"id":26,"field_type_id":44,"sample_type_id":6,"object_type_id":null,"created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00","sample_type":{"id":6,"name":"E coli strain","description":"A strain of E coli distinguished from others by genomic (not plasmid) modifications.","created_at":"2020-03-24T08:41:53.000-07:00","updated_at":"2020-03-24T08:41:53.000-07:00"}}],"sample_types":["E coli strain"],"object_types":[null]}]}],"object_types":[{"id":4,"name":"Total RNA 96 Well Plate","description":"96 Well plate of total RNA from customer","min":0,"max":1000000,"handler":"collection","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-03-19T10:30:41.000-07:00","updated_at":"2020-03-19T10:32:08.000-07:00","unit":"plate","cost":0.01,"release_method":"return","release_description":"","sample_type_id":1,"image":"","prefix":"M80C","rows":8,"columns":12,"sample_type_name":"RNA Sample"},{"id":6,"name":"Fragment Stock","description":"Fragment stock in 1.5 mL tube, usually stored in M20 fridge.","min":0,"max":1000,"handler":"sample_container","safety":"No safety information","cleanup":"No cleanup information","data":"No data","vendor":"No vendor information","created_at":"2020-03-24T08:41:54.000-07:00","updated_at":"2020-03-24T08:41:54.000-07:00","unit":"Fragment","cost":50.0,"release_method":"return","release_description":"","sample_type_id":3,"image":null,"prefix":"M20","rows":null,"columns":null,"sample_type_name":"Fragment"}],"operation_type":{"name":"RNA_QC","category":"RNA_Seq","deployed":false,"on_the_fly":false,"field_types":[{"ftype":"sample","role":"input","name":"Input Array","sample_types":["RNA Sample"],"object_types":["Total RNA 96 Well Plate"],"part":true,"array":true,"routing":"IS","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null},{"ftype":"sample","role":"output","name":"Frag_out","sample_types":["Plasmid"],"object_types":["Fragment Stock"],"part":false,"array":false,"routing":"f","preferred_operation_type_id":null,"preferred_field_type_id":null,"choices":null}],"protocol":"#Cannon Mallory\n#UW-BIOFAB\n#03/04/2019\n#malloc3@uw.edu\n#\n#\n#This protocol is for total RNA QC.  It Will take in a batch of samples, replate these\n#samples together onto a 96 well plate that will then go through a QC protocols including\n#getting the concentrations of the original sampole.  These concentrations will then be associated\n#with the original sample for use later.\n\n\n#Currently build plate needs a bit of work.  It works by order of input array and not by order of sample location on plate\n\n\nneeds \"Standard Libs/Debug\"\nneeds \"Standard Libs/CommonInputOutputNames\"\nneeds \"Standard Libs/Units\"\nneeds \"Collection_Management/CollectionDisplay\"\nneeds \"Collection_Management/CollectionTransfer\"\nneeds \"Collection_Management/CollectionActions\"\nneeds \"Collection_Management/SampleManagement\"\nneeds \"RNA_Seq/WorkflowValidation\"\nneeds \"RNA_Seq/KeywordLib\"\n\n\nclass Protocol\n  include Debug, CollectionDisplay, CollectionTransfer, SampleManagement\n  include CollectionActions, WorkflowValidation, CommonInputOutputNames, KeywordLib\n\n  TRANSFER_VOL = 20   #volume of sample to be transfered in ul\n\n\n  def main\n    validate_inputs(operations)\n    \n    working_plate = make_new_plate(C_TYPE)\n    \n    operations.retrieve\n\n    operations.make\n\n    operations.each do |op|\n      input_fv_array = op.input_array(INPUT_ARRAY)\n      add_fv_array_samples_to_collection(input_fv_array, working_plate)\n      transfer_from_array_collections(input_fv_array, working_plate, TRANSFER_VOL)\n    end\n    \n    store_input_collections(operations)\n    take_qc_measurments(working_plate)\n    trash_object(working_plate)\n\n  end\n\n\n  # Instruction on taking the QC measurements themselves.\n  # Currently not operational but associates random concentrations for testing\n  #\n  #TODO complete this and make it actually look at CSV Files\n  def take_qc_measurments(working_plate)\n    input_rcx = []\n    operations.each do |op|\n      input_array = op.input_array(INPUT_ARRAY)\n      input_items = input_array.map{|fv| fv.item}\n      arry_sample = input_array.map{|fv| fv.sample}\n      input_items.each_with_index do |item, idx|\n        item.associate(CON_KEY, rand(50..100))\n        sample = arry_sample[idx]\n        working_plate_loc_array = working_plate.find(sample)\n        working_plate_loc_array.each do |sub_array|\n          sub_array.push(\"#{item.get(CON_KEY)}\")\n          input_rcx.push(sub_array)\n        end\n      end\n    end\n\n    show do\n      title \"Perform QC Measurements\"\n      note \"Please Attach excel files\"\n      note \"For testing purposes each sample will be given a random concentration from 50 to 100 ng/ul\"\n      note \"This will eventually come from a CSV file\"\n      table highlight_rcx(working_plate, input_rcx)\n    end\n  end\nend\n","precondition":"def precondition(_op)\n  true\nend","cost_model":"def cost(_op)\n  { labor: 0, materials: 0 }\nend","documentation":"Documentation here. Start with a paragraph, not a heading or title, as in most views, the title will be supplied by the view.","test":"","timing":null}},{"library":{"name":"CsvDebugLib","category":"RNA_Seq","code_source":"module CsvDebugLib\n    CSV_DEBUG = \"Plate ID,Well Location\n    100,A1\n    100,B1\n    100,C1\n    100,D1\n    100,E1\n    100,F1\n    100,G1\n    100,A2\n    100,B2\n    100,C2\n    100,D2\n    100,E2\n    100,F2\n    100,G2\n    100,A3\n    100,B3\n    100,C3\n    100,D3\n    100,E3\n    100,F3\n    100,G3\"\nend"}},{"library":{"name":"KeywordLib","category":"RNA_Seq","code_source":"#Cannon Mallory\n#malloc3@uw.edu\n#\n#This is where all the standard keywords/values will live.\n\nmodule KeywordLib\n    MAX_INPUTS = 96\n    C_TYPE = \"96 Well Sample Plate\"\n    CON_KEY = \"Stock Conc (ng/ul)\"\n    QC2_KEY = \"C-DNA QC\"\n    CSV_KEY = \"csv\"\n\n    ADAPTER_PLATE = \"Adapter Plate\"\n    ADAPTER = \"Adapter Item\"\n\n    INPUT_PLATE = \"Input Plate\"\n    INPUT_ITEM = \"Input Item\"\n\nend"}},{"library":{"name":"WorkflowValidation","category":"RNA_Seq","code_source":"#Cannon Mallory\n#malloc3@uw.edu\n#\n#This includes all moduels that validate workflow parameters at run time\nneeds \"Standard Libs/CommonInputOutputNames\"\nneeds \"RNA_Seq/KeywordLib\"\n\nmodule WorkflowValidation\n  include CommonInputOutputNames, KeywordLib\n\n  \n  \n  #Validates that total inputs (from all operations)\n  #Ensures that all inputs doesnt exeed max inputs\n  #\n  # @operations OperationList list of all operations in the job\n  # @inputs_match_outputs Boolean if the number of inputs should match the number of outputs set as true\n  def validate_inputs(operations, inputs_match_outputs = false)\n    total_inputs = []\n    total_outputs = []\n    operations.each do |op|\n      total_inputs = total_inputs + op.input_array(INPUT_ARRAY).map!{|fv| fv.sample}\n      total_outputs = total_outputs + op.output_array(OUTPUT_ARRAY).map!{|fv| fv.sample}\n    end\n\n    a = total_inputs.detect{ |sample| total_inputs.count(sample) \u003e 1}\n    raise \"Sample #{a.id} has been included multiple times in this job\" if a != nil\n    raise \"The number of Input Samples and Output \n            Samples do not match\" if total_inputs.length != total_outputs.length \u0026\u0026 inputs_match_outputs\n    raise \"Too many samples for this job. Please re-lauch job with fewer samples\" if total_inputs.length \u003e MAX_INPUTS\n    raise \"There are no samples for this job.\"  if total_inputs.length \u003c= 0\n  end\n\n\n  def validate_concentrations(operations, range)\n    operations.each do |op|\n      op.input_array(INPUT_ARRAY).each do |fv|\n        conc = fv.item.get(CON_KEY)\n        raise \"Sample #{fv.sample.id} doesn't have a valid concentration for this operation\"if !range.cover? conc\n      end\n    end\n  end\n\n  def validate_cdna_qc(operations)\n    operations.each do |op|\n      op.input_array(INPUT_ARRAY).each do |fv|\n        qc = fv.item.get(QC2_KEY)\n        raise \"Item #{fv.item.id} doesn't have a valid C-DNA QC\" if qc != \"Pass\"\n      end\n    end\n  end\n  \n  \nend"}},{"library":{"name":"AssociationManagement","category":"Standard Libs","code_source":"# frozen_string_literal: true\n\n# Module with methods and classes that seek to help with associating data\n# to, and retrieving data from, items, operations, plans, collections, and parts.\n#\nmodule AssociationManagement\n  require 'matrix'\n\n  # Associates a key and value to the associations hash of the given object.\n  # Replaces an existing association for the given key.\n  #\n  # A part may be represented as a part item, or a collection and coordinate.\n  #\n  # @param object [DataAssociator]  the object to associate data\n  # @param key [String]  the key for the association\n  # @param data [serializable object]  the data for the association\n  # @param opts [Hash]  additional method options\n  # @option coord [Array]  row, column pair if the object is a collection\n  # @option data_matrix [String]  optional data matrix for a collection\n  def associate_data(object, key, data, opts = {})\n    AssociationMap.associate_data(object, key, data, opts)\n  end\n\n  # Returns the associated value from the associations hash of a given object.\n  # If an association doesn't exist for the key, returns nil.\n  #\n  # @param object [DataAssociator]  the object to associated data\n  # @param key [String]  the key for the association\n  # @param opts [Hash]  additional method options\n  # @option coord [tuple Array]  row, column of part if object is a collection.\n  # @option data_matrix [String]  optional data matrix\n  # @return [serializable object]  the value associated with the given key\n  def get_associated_data(object, key, opts = {})\n    AssociationMap.get_associated_data(object, key, opts)\n  end\n\n  # Defines a map to manage the associations for an {Item}, {Operation}, or\n  # {Plan} object, which are Aquarium classes that extend {DataAssociator}.\n  #\n  # Note: if `map` contains associations, it is necessary to call `map.save` for\n  #       the associations to be saved to Aquarium.\n  #\n  class AssociationMap\n    DATAMATRIX_KEY = 'part_data'\n\n    # Initializes an {AssociationMap} for the given item, operation, or plan.\n    #\n    # @param object [DataAssociator]  the object to which to associated data\n    def initialize(object)\n      @object = object\n      @map = {}\n\n      @object.associations.each do |datum|\n        @map[datum[0]] =\n          if @object.upload(datum[0]).nil?\n            datum[1]\n          else\n            UploadAssoc.new(datum[1], @object.upload(datum[0]))\n          end\n      end\n\n      if object.is_a? Collection\n        initialize_part_data\n        data_matrix_all(@object, @map[DATAMATRIX_KEY])\n      end\n    end\n\n    # Retrieves part_data from the data associations of constituent parts.\n    # achieves forward compatibility with AQ Part update\n    def data_matrix_all(coll, data_matrix)\n      pas = coll.part_associations\n      part_ids = pas.collect(\u0026:part_id)\n      das = DataAssociation.where(parent_class: 'Item', parent_id: part_ids)\n      pas.each do |pa|\n        data_matrix[pa.row][pa.column] = {}\n        das.select { |da| da.parent_id == pa.part_id }.each do |da|\n          data_matrix[pa.row][pa.column][da.key] = da.value\n        end\n      end\n      data_matrix\n    end\n\n    # All in one static method which associates a key and value\n    # to the associations hash of a given object. If an association already\n    # exists at the given key, it will be replaced. Can associate to parts of collection either\n    # using a part field value, or an optional coordinate specification with a collection\n    #\n    # @param object [DataAssociator]  the object to which data is to be associated. Can be an io field value\n    # @param key [String]  the key for the association\n    # @param data [serializable object]  the data for the association\n    # @param opts [Hash]  additional method options\n    # @option coord [tuple Array]  specify r, c index of the data matrix of the object to upload to,\n    #                   rather than directly to the object. Requires that object is a collection.\n    # @option data_matrix [String]  optionally, when associating to a part of a collection, use a\n    #                         data matrix besides the default one\n    def self.associate_data(object, key, data, opts = {})\n      defaults = { data_matrix: DATAMATRIX_KEY }\n      opts.merge defaults\n      raise 'Bad Arguments: cannot associate to a part and specify coords at the same time' if object.is_a?(FieldValue) \u0026\u0026 opts[:coord]\n      if object.is_a?(FieldValue)\n        assoc_map = AssociationMap.new(object.collection)\n        assoc_map.putrc(object.row, object.column, key, data)\n      elsif opts[:coord]\n        assoc_map = AssociationMap.new(object)\n        assoc_map.putrc(opts[:coord][0], opts[:coord][1], key, data)\n      else # Normal case that deals directly with object\n        assoc_map = AssociationMap.new(object)\n        assoc_map.put(key, data)\n      end\n      assoc_map.save\n    end\n\n    # All in one static method which gets an associated value\n    # from the associations hash of a given object. If an association doesn't\n    # exist at the given key, returns nil. Can get associations from parts of collection either\n    # using a part field value, or an optional coordinate specification with a collection\n    #\n    # @param object [DataAssociator]  the object to which data is to be associated, can be an io field value\n    # @param key [String]  the key for the association\n    # @param opts [Hash]  additional method options\n    # @option coord [tuple Array]  specify r, c index of the data matrix of the object to upload to,\n    #                   rather than directly to the object. Requires that object is a collection.\n    # @option data_matrix [String]  optionally, when retrieving association from a part of a collection,\n    #                         use a matrix besides the default one\n    # @return [serializable object]  the data stored in the associations of the given object at the given key\n    def self.get_associated_data(object, key, opts = {})\n      defaults = { data_matrix: DATAMATRIX_KEY }\n      opts.merge defaults\n      raise 'Bad Arguments: cannot get data from a part and specify coords at the same time' if object.is_a?(FieldValue) \u0026\u0026 opts[:coord]\n      if object.is_a?(FieldValue)\n        assoc_map = AssociationMap.new(object.collection)\n        return assoc_map.getrc(object.row, object.column, key)\n      elsif opts[:coord]\n        assoc_map = AssociationMap.new(object)\n        return assoc_map.getrc(opts[:coord][0], opts[:coord][1], key)\n      else # Normal case that deals directly with object\n        assoc_map = AssociationMap.new(object)\n        return assoc_map.get(key)\n      end\n    end\n\n    # Adds an association for the data with the key.\n    # The data must be serializable.\n    #\n    # @param key [String]  the key for the association\n    # @param data [serializable object]  the data for the association\n    # @param opts [Hash]  Additional Options\n    # @option tag  [String]  If putting an Upload, optionally specify an extra label\n    def put(key, data, opts = { tag: {} })\n      @map[key] = if data.is_a?(Upload)\n                    UploadAssoc.new(opts[:tag], data)\n                  else\n                    data\n                  end\n    end\n\n    # Adds an association for the data with the key, for\n    # a specific row, column coordinate within a collection\n    # If the data_matrix for the collection has not been created yet, it is initialized\n    #\n    # @requires  current object is a Collection, and r,c corresponds to a valid location in the object\n    # @param r [Integer]  the row of the part within the collection to associate to\n    # @param c [Integer]  the column of the part within the collection to associate to\n    # @param key [String]  the key for the association\n    # @param data [serializable object]  the data for the association\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    def putrc(row, column, key, data, data_matrix = DATAMATRIX_KEY)\n      # if the data_matrix for this collection does not exist yet, initialize it.\n      initialize_part_data(data_matrix)\n      @map[data_matrix][row][column][key] = data\n    end\n\n    # To be called when the object of association is a collection,\n    # establishes a matrix parallel to the sample matrix which can\n    # be used to store additional information about individual parts\n    # Each slot in the matrix will be a new empty hash.\n    #\n    # @param coll [Collection]  the object for which part-data matrix will be initialized\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    def initialize_part_data(data_matrix = DATAMATRIX_KEY)\n      raise \"Invalid Method Call: cannot associate part data to an object that isn't a collection\" unless @object.is_a?(Collection)\n      # TODO: fix the following so that can use the Base method\n      # coll = collection_from(@object.id)\n      coll = Collection.find(@object.id)\n      @map[data_matrix] = Array.new(coll.dimensions[0]) { Array.new(coll.dimensions[1]) { {} } } if @map[data_matrix].nil?\n    end\n\n    # Returns the associated data for the key, if any.\n    #\n    # @param key [String]  the key for the association\n    # @returns the data object for the key, `nil` otherwise\n    def get(key)\n      data = @map[key]\n      if data.is_a?(UploadAssoc)\n        data.upload\n      else\n        data\n      end\n    end\n\n    # Gets an association for the data with the key, for\n    # a specific row, column coordinate within a collection\n    # Returns the associated data for the key, if any.\n    #\n    # @requires  current object is a Collection, and r,c corresponds to a valid location in the object\n    # @param r [Integer]  the row of the part within the collection to associate to\n    # @param c [Integer]  the column of the part within the collection to associate to\n    # @param key [String]  the key for the association\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    # @returns the data object for the key, `nil` otherwise\n    def getrc(row, column, key, data_matrix = DATAMATRIX_KEY)\n      @map[data_matrix][row][column][key] unless @map[data_matrix].nil?\n    end\n\n    # Retrieve the associations for all parts of the collection\n    # as a matrix.\n    # @requires  current object is a collection\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n    # @returns  the data matrix, if one exists\n    def get_data_matrix(data_matrix = DATAMATRIX_KEY)\n      Matrix.rows(@map[data_matrix])\n    end\n\n    # Replace or initialize the data matrix for this object\n    # with a custom one.\n    # @requires  the current object is a collection\n    # `matrix` have the same row column dimensions as the collection\n    #\n    # @param new_matrix [Matrix]  the new data matrix\n    # @param data_matrix [String/Symbol]  optionally specify a data matrix (by key) to access besides the default one,\n    #                         for example, you might have the default part data, alongside a routing matrix\n\n    def set_data_matrix(matrix, data_matrix = DATAMATRIX_KEY)\n      @map[data_matrix] = matrix.to_a\n    end\n\n    # Saves the associations in this map to Aquarium.\n    def save\n      das = []\n      @map.each_key do |key|\n        if key == DATAMATRIX_KEY\n          das.concat save_data_matrix_alt(@object, @map[key])\n        elsif @map[key].is_a? UploadAssoc\n          # TODO: update this to lazy associate once aq is updated to hav lazy upload assoc (on master, just not on server yet)\n          @object.associate(key, @map[key].tag, @map[key].upload)\n        else\n          das \u003c\u003c @object.lazy_associate(key, @map[key])\n        end\n      end\n      DataAssociation.import(das, on_duplicate_key_update: [:object]) unless das.empty?\n      @object.save\n      nil\n    end\n\n    # saves part_data to the data associations of constituent parts.\n    # achieves forward compatibility with AQ Part update\n    # built off of set_data_matrix from collection.rb\n    def save_data_matrix_alt(coll, matrix, offset: [0, 0])\n      pm = coll.part_matrix\n      das = []\n\n      uniq_keys = matrix.flatten.map(\u0026:keys).flatten.uniq\n      dms_by_key = {}\n      uniq_keys.each do |key|\n        dms_by_key[key] = coll.data_matrix(key)\n      end\n\n      coll.each_row_col(matrix, offset: offset) do |x, y, ox, oy|\n        next unless !matrix[x][y].nil? \u0026\u0026 pm[ox][oy] # this part has das\n        matrix[x][y].each do |k, v|\n          if pm[ox][oy]\n            if dms_by_key[k][ox][oy]\n              da = dms_by_key[k][ox][oy]\n              da.object = { k =\u003e v }.to_json\n              das \u003c\u003c da\n            else\n              das \u003c\u003c pm[ox][oy].lazy_associate(k, v)\n            end\n          end\n        end\n      end\n\n      das\n    end\n\n    # Returns an array of all the keys in this map\n    def keys\n      @map.keys\n    end\n\n    # Returns the string representation of the map\n    def to_string\n      @map.to_s\n    end\n\n    alias to_s to_string\n  end\n\n  # private class that is used to deal with associating upload objects alongside their tag\n  class UploadAssoc\n    def initialize(tag, upload)\n      @upload = upload\n      @tag = tag || {}\n    end\n\n    def change_tag(new_tag)\n      @tag = new_tag\n    end\n\n    attr_reader :upload\n\n    attr_reader :tag\n  end\n\n  # Utilizes the part-data matrix of collections to store information about the history of\n  # parts of a collection. PartProvenance initializes and relies on two fields of every part-data\n  # slot: `source` and `destination`.\n  # `source` will store a list of item ids (with rc index if applicable),\n  # of all the ingredients used to make this part, and destination will use the same data format\n  # to record all of the places this part was used in.\n  # Item-Item provenance can technically be recorded as well with this library, but it will not\n  # be necessary.\n  #\n  module PartProvenance\n    SOURCE = 'source'\n    DESTINATION = 'destination'\n\n    # Record an entry to the provenance data between two parts, or a part and an item.\n    # This will populate the destination field of `from`, and the source field\n    # of the `to` in their respective associations. If from_coord or to_coord is specified, then\n    # the associations of the part of the from/to collection at that coordinate will\n    # populated instead.\n    #\n    # @param opts [Hash]  Arguments specifying which objects to record relation for\n    # @option from [Item/Collection]  the item or collection where sample transfer originated\n    # @option to [Item/Collection]  the item or collection for destination of sample transfer\n    # @option from_coord [Tuple Array]  optionally, specify the coordinate selecting a part of the collection, if `to` was a collection\n    # @option to_coord [Tuple Array]  optionally, specify the coordinate selecting a part of the collection, if `from` was a collection\n    # @option additional_relation_data [Hash]  optionally, add additional key/value pairs to add to both object's routing data\n    #                         for this relation. For example, you might want to specify the volume of the transfer,\n    #                         or which colony was picked from a plate\n    # @option from_map [AssociationMap]  existing AssociationMap for the given from-object, required to successfully associate provenance to\n    #                           the `from` item\n    # @option to_map [AssociationMap]  existing AssociationMap for the given to-object, required to successfully associate provenance to\n    #                           the `to` item\n    def add_provenance(opts = {})\n      if opts[:from] == opts[:to] # special case: provenance between two parts on the same collection\n        opts[:from_map] = opts[:to_map] # ensure from map and to map are the same object for this case\n      end\n\n      # creating information hashes to represent `from` and `to` relationship data\n      from_info = serialize_as_simple_tag(opts[:from], opts[:from_coord], opts[:additional_relation_data])\n      to_info = serialize_as_simple_tag(opts[:to], opts[:to_coord], opts[:additional_relation_data])\n\n      # in destination field of `from`, add information tag representing `to`\n      append_to_association(opts[:from_map], DESTINATION, to_info, coord: opts[:from_coord]) if opts[:from_map]\n\n      # in source field of `to`, add information tag representing `from`\n      append_to_association(opts[:to_map], SOURCE, from_info, coord: opts[:to_coord]) if opts[:to_map]\n    end\n\n    # Retrieves a list of sources that were used to construct the given part\n    # of a Collection\n    #\n    # @param object [FieldValue/Collection]  the part of interest, or the collection which\n    #                 contains the part of interest. For the second case, coord must also be specified\n    # @param coord [Tuple Array]  the r,c index of the target part\n    def sources(object, coord = nil)\n      if coord\n        AssociationMap.get_associated_data(object, SOURCE, coord: coord)\n      else\n        AssociationMap.get_associated_data(object, SOURCE)\n      end\n    end\n\n    # Retrieves a list of destinations that were made using the given part\n    # of a Collection\n    #\n    # @param object [FieldValue/Collection]  the part of interest, or the collection which\n    #                 contains the part of interest. For the second case, coord must also be specified\n    # @param coord [Tuple Array]  the r,c index of the target part\n    def destinations(object, coord = nil)\n      if coord\n        AssociationMap.get_associated_data(object, DESTINATION, coord: opts[:coord])\n      else\n        AssociationMap.get_associated_data(object, DESTINATION)\n      end\n    end\n\n    # For the given associatable target object, appends or concatenates the given datum_to_append to the association\n    # at `key` for that object\n    #\n    # @param association_map [AssocioationMap]  an AssociationMap that will have its associations appended to.\n    # @param key [String/Symbol]  The association key which maps to an appendable object\n    # @param datum_to_append [Serializable Object]  the element to append to the list at the value for the given key\n    # @param opts [Hash]  additional options\n    # @option coord [Tuple array]  coordinate of target part, if association target is a collection\n    def append_to_association(association_map, key, datum_to_append, opts = {})\n      if opts[:coord] # we will be interacting with the associations of a part of a collection if coord is specified\n        association_map.putrc(opts[:coord][0], opts[:coord][1], key, []) if association_map.getrc(opts[:coord][0], opts[:coord][1], key).nil?\n        association_map.getrc(opts[:coord][0], opts[:coord][1], key) \u003c\u003c  datum_to_append\n      else\n        association_map.put(key, []) if association_map.get(key).nil?\n        association_map.get(key) \u003c\u003c datum_to_append\n      end\n    end\n\n    # Given an item, or a part of a collection, serializes it into a simple tag which can be used to retrieve it.\n    #\n    # @param item [Item/FieldValue]  can be either an Item, or\n    #                         an i/o object corresponding to a part of a collection, which can be thought of\n    #                         as constituting a 'sub item'\n    def serialize_as_simple_tag(item, coord, additional_info)\n      info = if item.collection? \u0026\u0026 coord\n               { id: item.id, row: coord[0], column: coord[1] }\n             elsif (item.is_a? Item) || (item.is_a? Collection)\n               { id: item.id }\n             else\n               raise 'Argument is neither a part nor an item'\n             end\n      info.merge!(additional_info) unless additional_info.nil?\n      info\n    end\n  end\nend\n"}},{"library":{"name":"CommonInputOutputNames","category":"Standard Libs","code_source":"module CommonInputOutputNames\n\n    INPUT_YEAST = 'Yeast Culture'\n    OUTPUT_YEAST = 'Yeast Culture'\n    MEDIA = 'Media'\n    DNA = 'DNA'\n    \n    INPUT_SAMPLE = 'Input Sample'\n    OUTPUT_SAMPLE = 'Output Sample'\n\n    INPUT_ARRAY = \"Input Array\"\n    OUTPUT_ARRAY = \"Output Array\"\n\n    FORWARD_PRIMER = 'Forward Primer'\n    REVERSE_PRIMER = 'Reverse Primer'\n    TEMPLATE = 'Template'\n    FRAGMENT = 'Fragment'\n    PROGRAM = 'Program'\n    PRIMER_PLATE = '96-Well Primer Aliquot Plate'\n\nend"}},{"library":{"name":"Debug","category":"Standard Libs","code_source":"module Debug\n  def print_object obj\n    if [Numeric, String].any? { |c| obj.is_a? c }\n      obj\n    elsif [Array].any? { |c| obj.is_a? c }\n      obj.map { |item| print_object item }\n    elsif [Hash].any? { |c| obj.is_a? c }\n      Hash[obj.map { |k, v| [k, print_object(v)] }]\n    else\n      s = obj ? obj.id.to_s : \"\"\n      s += \" #{obj.name}\" if obj.class.method_defined? :name\n      s\n    end\n  end\n\n  def log_info *args\n    if debug\n      show do\n        title \"Debug slide (#{args.length} #{\"arg\".pluralize args.length})\"\n\n        args.each do |arg|\n          note \"#{arg.class}: #{print_object arg}\"\n        end\n      end\n    end\n  end\n\n    def inspect(object, ident=nil)\n        show do\n            title \"\u003cspan style=\\\"background-color:yellow\\\"\u003eINSPECTING #{ident} (#{object.class})\u003c/span\u003e\"\n            if object.kind_of?(Array)\n              table object\n            else\n              note object.to_json\n            end\n        end\n    end\nend\n"}},{"library":{"name":"PlanParams","category":"Standard Libs","code_source":"module PlanParams\n\n  # Gets :options from the plan associations and uses it to override default_plan_params\n  #\n  # @return [Hash] plan_params\n  def update_plan_params(plan_params:, opts:)\n    if opts.present?\n      opts = JSON.parse(opts, { symbolize_names: true })\n      plan_params.update(opts)\n    end\n    plan_params\n  end\n\n  #gets the options on the first operaton of a plan\n  def get_opts(operations)\n    operations.first.plan.associations[:options]\n  end\n\n  #gets the options on a specific operation\n  def get_op_opts(op)\n    op.plan.associations[:options]\n  end\n\n  #sets plan params as a temporary association to the operation under the :plan_params key\n  def set_temporary_op_params(op, default_plan_parameters)\n      opts = get_op_opts(op)\n      op.temporary[:plan_params] = update_plan_params(plan_params: default_plan_params, opts: opts)\n  end\n \nend"}},{"library":{"name":"Units","category":"Standard Libs","code_source":"module Units\n    \n    EMPTY = -1\n    \n    # Volume\n    MICROLITERS = 'ul'\n    MILLILITERS = 'ml'\n    \n    # Weight\n    NANOGRAMS = 'ng'\n    MICROGRAMS = 'g'\n    \n    # Concentration\n    PICOMOLAR = 'pM'\n    NANOMOLAR = 'nM'\n    MICROMOLAR = 'M'\n    MILLIMOLAR = 'mM'\n    MOLAR = 'M'\n    \n    # Temperature\n    DEGREES_C = 'C'\n    \n    # Time\n    MINUTES = 'min'\n    SECONDS = 'sec'\n    HOURS ='hr'\n    # Force\n    TIMES_G = 'x g'\n    \n    # R/DNA Length\n    BASEPAIRS = 'bp'\n    KILOBASEPAIRS = 'kbp'\n    MEGABASEPAIRS = 'mbp'\n    GIGABASEPAIRS = 'gbp'\n    \n    # Voltage\n    VOLTS = 'V'\n\n    def self.qty_display(qty)\n        \"#{qty[:qty]} #{qty[:units]}\"\n    end\n    \n    def qty_display(qty)\n        \"#{qty[:qty]} #{qty[:units]}\"\n    end\n    \n    def add_qty_display(options)\n        new_items = {}\n        \n        options.each do |key, value|\n            key =~ /^(.+_)+([a-z]+)$/\n            \n            case $2\n            when 'microliters'\n                units = MICROLITERS\n            when 'milliliters'\n                units = MILLILITERS\n            when 'minutes'\n                units = MINUTES\n            else\n                next\n            end\n            \n            qty = value.to_f\n            \n            new_items[\"#{$1}qty\".to_sym] = { qty: qty, units: units }\n        end\n        \n        options.update(new_items)\n    end\n    \n    # Return the unit constant for the the unit name if there is one.\n    #\n    # @param unit_name [String] the name of the unit\n    # @returns the value of the constant with the given name\n    # @raises BadUnitNameError if the name is not the name of a defined unit\n    def self.get_unit(unit_name:)\n        self.const_get(unit_name.upcase)\n      rescue\n        raise BadUnitNameError.new(name: unit_name)\n    end\n    \n    # Exception class for bad unit name arguments to Units::get_unit.\n    #\n    # @attr_reader [String] name  the bad unit name\n    class BadUnitNameError \u003c StandardError\n        attr_reader :name\n        \n        def initialize(msg: \"Unknown unit name\", name:)\n            @name = name\n            super(msg)\n        end\n    end\n    \n    # Return a key for the measure hash defined on the given object type.\n    #\n    # The measure hash must be defined in the data proerty of the object type as JSON.\n    # For instance\n    #\n    #   { \"measure\": { \"type\": \"concentration\", \"unit\": \"micromolar\" } }\n    #\n    # The key is constructed as the type name, an underscore, and the unit name.\n    #\n    # @param object_type [ObjectType] the object type\n    # @returns the key for the measure of the the object type if there is one\n    # @raises MissingObjectTypeMeasure if the object type has no measure data_object\n    def self.get_measure_key(object_type:)\n        data_object = object_type.data_object\n        raise MissingObjectTypeMeasureError.new(name: object_type.name) if !data_object.key?(:measure)\n        \n        measure = object_type.data_object[:measure]\n        type_name = measure[:type]\n        unit_name = measure[:unit]\n        \"#{type_name}_#{self.get_unit(unit_name: unit_name)}\"\n    end\n    \n    # Exception class for an object type with out a measure hash definition.\n    #\n    # @attr_reader [String] name  the name of the object type where measure has was expected\n    class MissingObjectTypeMeasureError \u003c StandardError\n        attr_reader :name\n        \n        def initialize(msg: \"ObjectType has no measure in data object\", name:)\n            @name = name\n            super(msg)\n        end\n    end\n   \nend"}}]}